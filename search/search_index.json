{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cryptography Primer","text":"<p>Stay up to date</p> <p>\ud83d\udea7 This site is currently in early development. \ud83d\udea7</p> <p>Cryptography Primer aims to be your go-to place for precise, well-researched and easy-to-understand info on cryptographic algorithms and systems.</p> <p>The author is actively working on fine-tuning existing content and adding new content every day.</p> <p>Follow  @CryptPrimer on Twitter to stay up to date and learn about new content. I'd also love to hear your opinion and feedback!</p> Disclaimer: How to use recommendations from Cryptography Primer <p>The recommendations on Cryptography Primer are based on research on multiple sources that are freely available online, such as:</p> <ul> <li>Research papers available on e.g. arxiv.org1</li> <li>Recommendations of Cryptographic Library authors</li> <li>BSI technical guidelines4</li> <li>NIST publications5</li> <li>Blogs of reknown cryptographers or cybersecurity experts</li> <li>crypto.stackexchange.com2</li> <li>security.stackexchange.com3</li> <li>and occasionally other sources</li> </ul> <p>As should always be the case, you should not take recommendations from a single source for granted, but instead find at least a second - or better, third - source that confirms this recommendation.</p> <p>Also, if you are using recommendations for anything that will be used in a production setting or will be used by anyone that relies on it's cryptograhic properties, it is highly recommended to let your concept and implementation being reviewed by a reknown cybersecurity firm.</p> <p>That being said, the author hopes that Cryptography Primer helps you find the correct algorithm to use for your scenario, and find the correct parameters and modes for a safe implementation.</p>"},{"location":"#content","title":"Content","text":"Encryption Overview <p>         Learn all about the different kinds of encryption algorithms and see a comparison of common algorithms including information about their level of security.          </p> Learn more AES in detail <p>         Learn all about AES and how to apply it securely in your application.         </p> Learn more ChaCha in detail <p>         Learn all about ChaCha and how to apply it securely in your application.         </p> Learn more Hashing, Signing and MAC <p>         What are hashing, signing and MAC (Message Authentication Code) used for and what is the difference between these?         </p> Learn more"},{"location":"#roadmap","title":"Roadmap","text":"<p>Roadmap</p> <p>The following topics are planned to be added in the future:</p> <ul> <li>Encryption algorithms:<ul> <li>ECIES</li> <li>RSA</li> <li>Practical attacks on encryption algorithms and how to prevent them</li> </ul> </li> <li>Key derivation:<ul> <li>Overview and comparison</li> <li>Password-based key derivation</li> <li>Key derivation for other scenarios</li> </ul> </li> <li>Hashing functions:<ul> <li>SHA2 family</li> <li>SHA3 familiy</li> <li>Blake2</li> <li>Blake3</li> <li>Practical collisions for hashing functions and their impact</li> </ul> </li> <li>Digital Signatures:<ul> <li>EdDSA</li> <li>ECDSA</li> <li>RSA</li> </ul> </li> <li>Message Authentication Codes<ul> <li>Overview and Comparison</li> <li>...</li> </ul> </li> <li>Public Key Infrastructure<ul> <li>PKI explained</li> <li>TLS explained</li> <li>x.509 Certificates</li> <li>Certificate Signing and Verification</li> </ul> </li> <li>Cryptography in widespread use<ul> <li>WPA (WiFi)</li> <li>PGP</li> <li>SSH</li> <li>Bluetooth</li> <li>HTTPS</li> </ul> </li> <li>History<ul> <li>The history of cryptography from ancient until today</li> <li>A glimpse in the future: Quantum Computer and cryptography</li> </ul> </li> </ul> <ol> <li> <p>arXiv.org e-Print archive \u21a9</p> </li> <li> <p>Cryptography Stack Exchange \u21a9</p> </li> <li> <p>Information Security Stack Exchange \u21a9</p> </li> <li> <p>BSI - Cryptography on bsi.bund.de\u00a0\u21a9</p> </li> <li> <p>NIST Computer Security Resource Center on nist.gov\u00a0\u21a9</p> </li> </ol>"},{"location":"encryption/","title":"Encryption","text":""},{"location":"encryption/#overview-and-comparison","title":"Overview and Comparison","text":"<p>On this page, you will learn what...</p> <ul> <li>Symmetric Encryption (also known as Private Key Encryption),</li> <li>Asymmetric Encryption (also known as Public Key Encryption),</li> <li>Authenticated Encryption (AE)</li> <li>Authenticated Encryption with Associated Data (AEAD)</li> </ul> <p>... are and where to learn more about the different algorithms that implement these.</p> <p>Overview of encryption algorithms</p> Algorithm Key Sizes Type Authentication?(AE or AEAD) Recommendation AES 128, 192 or 256 Bits <p>Symmetric</p>128 Bit Block Cipher <p>\u2705</p>via GCM mode <p>Recommended</p><p>This algorithm is considered very secure and widely studied and deployed. GCM or CBC modes are recommended.</p> ChaCha 256 Bits <p>Symmetric</p>Stream Cipher <p>\u2705</p>via Poly1305 <p>Recommended</p><p>ChaCha20 is considered very secure and is widely studied and deployed. Use of Poly1305 is recommended.</p> RSA &gt;= 1028 Bits <p>Asymmetric</p>Block Cipher ? <p>Recommended</p><p>This algorithm is considered very secure. Usually used with an symmetric encryption algorithm, while RSA \"only\" encrypts the symmetric key.</p> ECIES 256 Bits <p>Asymmetric (Hybrid)</p>Block Cipher or Stream Cipher possible ? <p>Recommended (but can be hard to implement)</p><p>This encryption scheme is considered very secure. It is not a precicse defined algorithm, but instead a framework to implement encryption when knowing the receiver's Elliptic Curve public key. It can be used with symmetric encryption algorithms (recommended: AES or ChaCha20).</p> Camellia 128, 192 or 256 Bits <p>Symmetric</p>Block Cipher \u274c <p>Considered secure</p><p>This algorithm is considered secure, but is not as widely studied or deployed as AES or ChaCha20 3DES 112 or 168 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Less secure than AES and ChaCha20</p><p>This algorithm is not inherently insecure, but it is less secure than AES or ChaCha20, and computationally more expensive.</p> DES 56 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> Blowfish 32-448 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> <p>ARC4</p>(aka \"RC4\") 40-2048 Bits Symmetric Stream Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> IDEA 128 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p>"},{"location":"encryption/#what-is-encryption","title":"What is Encryption?","text":"<p>With \"encryption\" we mean a way to alter a given \"plaintext\" (although this often is not only text, but can be arbitrary data, such as files or a byte stream) to make it incomprehensible without knowing some kind of \"secret\". Encryption reaches one of the fundamental goals of cryptography: Confidentiality.</p> <p>Modern encryption schemes - and only those are recommended on this site - also provide Authenticity, which guarantees that the ciphertext and therefore the plaintext have not been altered without knowing the secret key. This is a very important attribute of an encryption scheme, because modifying the ciphertext can be a powerful attack vector.</p> <p>There are two fundamentally different approaches to encryption. One is called \"Symmetric Encryption\" (also known as Private Key Encryption) and the other is called \"Asymmetric Encryption\" (also known as Public Key Encryption).</p>"},{"location":"encryption/#what-is-symmetric-encryption","title":"What is Symmetric Encryption?","text":"<p>(Also known as Private Key Encryption)</p> <p>In Symmetric Encryption, the \"secret\" that is used to make the \"plaintext\" incomprehensible (this incomprehensible form is called \"ciphertext\") is the same as the secret that is used to decrypt the ciphertext back into plaintext. This means that the sender and the recipient of the ciphertext need to know exactly the same secret. This secret is called the \"Private Key\". It is \"private\", because it must only be known to the peers that are allowed to know the plaintext.</p> <p>The advantage of symmetric encryption is it's speed, because it only requires relatively easy calculations.</p> <p>The biggest downside of symmetric encryption is that the private key needs to be shared between the sender and the recipient. This yields the problem that somehow this secret private key must be exchanged before the ciperhtext can be decrypted. This in itself can be a problem, especially when communication takes place over a public medium such as the internet or via radio frequencies.</p> <p>This narrows the use case of Symmetric Encryption to situations where this secret can be securely shared between the sender and the receipient. These are some common ways to exchange the secret key:</p> <ul> <li>Pre-sharing the key over a secured medium - e.g. separately writing the key to the system that encrypts, and the system that decrypts the data</li> <li>Key exchange algorithms such as Diffie-Hellman (DH) and Elliptic Curve Diffie-Hellman (ECDH)</li> <li>Encrypting the secret key alongside the ciphertext using an asymmetric encryption scheme</li> </ul> <p>Popular Symmetric Encryption algorithms are AES, ChaCha20, 3DES and DES. While AES and ChaCha20 are state-of-the-art secure, you should not use DES or 3DES anymore, because they have been provem to be breakable.</p>"},{"location":"encryption/#what-is-asymmetric-encryption","title":"What is Asymmetric Encryption?","text":"<p>(Also known as Public Key Encryption)</p> <p>Asymmetric Encryption does not pose the problem that a secret must be shared between the sender and the receipient, because encryption takes place with a Public Key and decryption can be done with a Private Key.1. The Public Key - as the name suggests - can be shared freely and must not be transmitted securely. You can post it on the internet and it will not be a problem, because you can not decrypt ciphertext with the Public Key that was encrypted using the Public Key. Hence, when a sender wants to send a message securely to a receipient, it must know the receipient's Public Key, can encrypt a message using the Public Key, and the receipient c an decrypt it using it's Private Key.</p> <p>So the advantage of Asymmetric Encryption is that it is not required for a secret to be shared between the sender and the receipient, and hence no secure channel must be established before an encrypted message can be exchanged.</p> <p>But the disadvantage of asymmetric encryption is that it is compute intensive, and hence can not be used where scale or speed is of importance.</p> <p>To mitigate this main disadvantage, Asymmetric Encryption is usually combined with Symmetric Encryption in a way that the shared secret (Private Key) for the Symmetric Encryption will be encrypted using Asymmetric Encryption and the actual message is then encrypted using the shared secret and a Symmetric Encryption algorithm. This way, only a tiny bit of the transported data - the shared secret (Private Key of the Symmetric Encryption) - must be encrypted using the compute-expensive Asymmetric Encryption algorithm, and the main content of the transported data can be encrypted using the fast Symmetric Encryption.</p> <p>Popular Asymmetric Encryption algorithms are RSA and Elliptic Curves, but they are seldomely used alone for encryption.</p>"},{"location":"encryption/#what-is-authenticated-encryption-ae","title":"What is Authenticated Encryption (AE)?","text":"<p>Encryption does not guarantee that the sender of a ciphertext knows the Private Key. Of course you need a Private Key to construct a plausible ciphertext, but you can also modify a ciphertext - or completely guess a ciphertext from scratch - without knowing the Private Key as an attacker. This is called CCA and usually poses a problem to an encryption system, because it can help to break the security.</p> <p>Authenticated Encryption can be used to mitigate this risk, because it can authenticate the ciphertext and/or plaintext to be assembled by a sender that knows the Private Key. The decryption algorithm will not only decrypt the message, but also check a MAC against the message and only continue decryption if the MAC is constructed correctly.</p> <p>It is strongly advised to only use Authenticated Encryption. When Authenticated Encryption is not feasible, it is strongly advised to separately authenticate the ciphertext using Encrypt-then-MAC2.</p> <p>A popular and very secure cipher that supports authenticated encryption is ChaCha20-Poly1305.</p>"},{"location":"encryption/#what-is-authenticated-encryption-with-associated-data-aead","title":"What is Authenticated Encryption with Associated Data (AEAD)?","text":"<p>AEAD is an extension of AE that allows sending plaintext data alongside the ciphertext that can be read - and later authenticated by the recipient without previously knowing the private key.</p> <p>One exampe could be that the associated data contains an identifier that the recipient can use to look up the private key that is required the decrypt and authenticate the message.</p> <p>A popular and very secure cipher that supports AEAD is AES-GCM. ...</p> <ol> <li> <p>Or the other way around: It's also possible to encrypt using the Private Key and decrypt using the Public Key - although this often does not make too much sense, because the Public Key could be available to anybody\u00a0\u21a9</p> </li> <li> <p>All the crypto code you\u2019ve ever written is probably broken as blogged by Tony Arcieri.\u00a0\u21a9</p> </li> </ol>"},{"location":"hash_sign_mac/","title":"What is the difference between Hashing, Signing and MAC?","text":"<p>Hashes, MACs and digital signatures are primitives of cryptography, where hashes are also used outside of cryptography - e.g. to validate that a message has not been corrupted during transport.</p> <p>Hashes, MACs and digital signatures have a few things in common:</p> <ul> <li>They can be used to validate the \"integrity\" of a message - this means that you can be sure that the message was not corrupted if it matches the hash, signature or MAC that you compare it with.</li> <li>The original message can not be extracted from them</li> <li>Hence, they don't encrypt messages and are not encryption algorithms</li> </ul> <p>Here is a table showing the differences of the possibilities for each primitive:</p> Feature Hash Message Authentication Code (MAC) Digital Signature Validate that data has not been tampered with or has been corrupted (\"Integrity\") \u2705 \u2705 \u2705 Validate the sender of a message by using the Private Key (\"Authentication\") \u274c \u2705 \u2705 Validate the sender of a message by using the Public Key (\"Authentication\") \u274c \u274c \u2705 Prove that the sender has written and published a message (\"Non-Repudiation\") \u274c \u274c \u2705"},{"location":"hash_sign_mac/#what-are-use-cases-for-hashes","title":"What are use-cases for hashes?","text":"<p>A hash basically \"reduces\" an arbitrary large message into a fixed size digest in a non-reversible way. In particular, a hash function aims to do this in a way that possible collisions are as unlikely as possible. Nowadays, when you say \"hash function\", you usually mean cryptographic hash functions. There are non-cryptographic hash functions2, too (but some even refuse to call those hash functions): Most notably CRC3 (cyclic redundancy check), which is often used to verify that data has not been (unintentionally) corrupted during transport.</p> <p>But even cryptographic hash functions can be used for non-cryptographic as well as cryptographic use cases:</p>"},{"location":"hash_sign_mac/#non-cryptographic-use-cases-for-hash-functions","title":"Non-Cryptographic use-cases for hash functions","text":"<p>Here are some examples how hash functions are used in non-cryptographic context:</p> <ul> <li>Validate that a message has not been corrupted (or modified) during transport. For example, you can often find hashes next to a download link that can be used to validate that the file has exactly the same content as it supposed to have after you have downloaded it.</li> <li>\"Shrink\" information to a unique identifier that can be used for lookups. For example, you can look up a whole sentence or even a whole paragraph of text in a database by using it's hash, instead of comparing all characters of the paragraph in the database.</li> </ul>"},{"location":"hash_sign_mac/#cryptographic-use-cases-for-hash-functions","title":"Cryptographic use-cases for hash functions","text":"<p>Here are some examples how hash functions ar used in cryptograhpic context:</p> <ul> <li>Usually digital signatures are not applied to the whole message or data block, but on a hash digest of that message. In this scenario, the collision-resistance of the hash function is of utter importance45.</li> <li>Store passwords (TODO: Add a dedicated chapter to this topic).</li> <li>Some MAC algorithms are based on hash functions - these are called \"HMAC\" (hash-based message authentication code) and basically build a hash on a mixup of the Private Key and the message.</li> </ul>"},{"location":"hash_sign_mac/#comparison-of-hashing-functions","title":"Comparison of hashing functions","text":"Name Digest Sizes Description SHA2 224, 256, 384, 512 <p>Recommended</p><p>SHA2-family hashing functions are state-of-the-art and considered very secure. SHA2 is not less secure than SHA3.<p></p>Also known as SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.</p> SHA3 224, 256, 384, 512 <p>Recommended</p><p>SHA3-family hashing functions are state-of-the-art and considered as secure as SHA2. SHA3 was inventend as an alternative to SHA2 in case that SHA2 would be broken, but is computationally more expensive than SHA2.</p><p>Also known as SHA3/224, SHA3/256, SHA3/384 and SHA3/512.</p> SHA1 160 Bit <p>Not recommended</p><p>There are practical known collission attacks for SHA1.</p> MD5 128 Bit <p>Not recommended</p><p>There are practical known collission attacks for MD5.</p>"},{"location":"hash_sign_mac/#what-are-use-cases-for-digital-signatures","title":"What are use-cases for digital signatures?","text":"<p>Digital signatures also provide the integrity validation function of hashes. But additionally, digital signatures let you verify that the sender of the message is authentic, e.g. the message originates from the source that you expected.</p> <p>Because digital signatures are using \"asymmetric cryptography\", you can use the Public Key to validate the integrity and authenticity of the message. This has the advantage that you do not need to share a common Private Key between the sender and the recipient.</p> <p>Use-cases for digital signatures:</p> <ul> <li>Publish a message and \"sign\" it so that everyone can verify that it has been written and published by you.</li> <li>For example, TLS (and therefore HTTPS, which builds on TLS) uses digital signatures to authenticate the server behind the domain that you have requested data from.</li> <li>The underlying building block for this are x.509 certificates that are also widely used in other systems where it is important to let anybody know that a \"certificate\", that provides arbitrary permissions or identifications, can be trusted.</li> <li>Mobile platforms such as Apple's iOS and Google's Android use digital signatures to sign apps in they App Store/Play Store so that the system is able to trust these apps (and in turn is able to block running untrusted apps).</li> </ul>"},{"location":"hash_sign_mac/#comparison-of-digital-signature-algorithms","title":"Comparison of digital signature algorithms","text":"Name Description EdDSA <p>Recommended</p><p>This algorithm is a variant of DSA, but uses \"twisted Edwards curves\", which have a few advantages1:</p><p><ul><li>High performance on a wide range of systems</li><li>More resilient to side-channel attacks</li><li>Does not require a unique random number for each messsage</li></ul></p> ECDSA <p>Recommended</p><p>This algorithm is a variant of DSA, but uses elliptic curves instead of modular arithmetic. This decreases the required key size for the same safety level drastically. Additionally, the same Public/Private Key pair could be used for encryption using ECIES, which could be an advantage.</p> RSA <p>Recommended</p><p>RSA can be used for digital signatures and asymmetric encryption using the same Public/Private key pair. Compared to ECDSA and EdDSA it has much larger key sizes and is computationally more expensive. However, if your system can profit from using the same Private/Public key pair for signing and encrypting, and the somewhat rarely used ECIES is not a feasible option for you, RSA can be a good fit.</p> DSA <p>Use EdDSA, ECDSA or RSA instead (preference in this order)</p><p>DSA was the first standardised digital signature algorithm and is still considered secure. However, the large key size and expensive computations makes it less pratical than it's modern successors such as ECDSA and EdDSA.</p>"},{"location":"hash_sign_mac/#what-are-macs-used-for","title":"What are MACs used for?","text":"<p>Hint</p> <p>You should usually not require to use MACs yourself, because these are often part of an \"authenticated encryption\" cipher such as AES-GCM or ChaCha20-Poly1305.</p> <p>MACs are similar to digital signatures, but they do not have the advantage of asymmetric cryptography, because they require the same Private Key for \"signing\" a message and authenticating the message.</p> <ul> <li>MACs are of utter importance to prevent CCA on ciphers6 - every cipher should include message authentication, which is usually accomplished by using a MAC.</li> </ul> <ol> <li> <p>What is the difference between ECDSA and EdDSA? on crypto.stackexchange.com\u00a0\u21a9</p> </li> <li> <p>List of hash functions on Wikipedia\u00a0\u21a9</p> </li> <li> <p>CRC on Wikipedia\u00a0\u21a9</p> </li> <li> <p>MD5 considered harmful today - Creating a rogue CA certificate from Eindhoven University of Technology\u00a0\u21a9</p> </li> <li> <p>Announcing the first SHA1 collision on Google Security Blog\u00a0\u21a9</p> </li> <li> <p>All the crypto code you\u2019ve ever written is probably broken as blogged by Tony Arcieri.\u00a0\u21a9</p> </li> </ol>"},{"location":"imprint/","title":"Imprint","text":"<p>Daniel Albuschat Ringstra\u00dfe 6a 42499 H\u00fcckeswagen GERMANY</p>"},{"location":"imprint/#contact","title":"Contact","text":"<p>You can reach out to the author of this website via:</p> <ul> <li> GitHub (please open a ticket)</li> <li> Twitter</li> <li> Xing</li> </ul> <p>https://www.cryptography-primer.info</p>"},{"location":"imprint/#privacy-agreement","title":"Privacy Agreement","text":"<p>This website does not use a single cookie and does not collect any data from you.</p>"},{"location":"index2/","title":"Cryptography Primer","text":"<p>This is your go-to place to learn about cryptography and make educated and secure decisions.</p> <ul> <li>Learn about foundational cryptographic algorithms</li> <li>Understand how and where an algorithm can be applied and what constraints exist</li> <li>Choose the right algorithm, mode and parameters</li> </ul> <p>The Cryptography Primer is designed to be easily understandable without deep mathematical knowledge. In fact, we don't include information about the mathematical foundations of the algorithms, but provide information about the real-world consequences of the underlying math instead.</p> <p>Do you have some special topic, algorithm or technology that you want to learn about? Head straight to the glossary where you should find everything you should need to know.</p> To the Glossary"},{"location":"index2/#explore-topics","title":"Explore Topics","text":"Encryption <p>         Learn all about the different encryption and decryption algorithms, their up- and downsides, use-cases and their security.          </p> Learn more Hashing <p>         Hashing is an important part of many cryptographic systems and is also often used stand-alone for verification that the data you have received is actually the data that you want.         </p> Learn more Signing <p>         With cryptographic signing you can securely verify that information comes from the sender you are expecting. Learn about different signing mechanisms and when and how to use them.         </p> Learn more Public Key Infrastructure <p>         The global Public Key Infrastructure (PKI) is a very important part of today's secure web, but it is also possible to build closed PKIs for special purposes.         </p> Learn more Popular Cryptographic Systems <p>Even when using the most secure algorithms, one can still build a cryptographic system that is not very safe. That's why there are use-case specific systems such as PGP, SSH, TLS, WPA (WiFi), Bluetooth and others.</p> Learn more History <p>Learn about important historic events in the cryptographic world.</p> Learn more"},{"location":"index2/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Key Derivation Functions</li> <li>Secure Multi-Party Computation</li> <li>Ring Signatures</li> <li>Homomorphic Encryption</li> <li>Post-Quantum Cryptography</li> </ul>"},{"location":"index2/#algorithm-overview","title":"Algorithm Overview","text":"<p>Here is an overview of all cryptographic algorithms that are relevant today, with links to detailed information.</p> <p>Overview of encryption algorithms</p> Algorithm Key Sizes Type Authentication?(AE or AEAD) Recommendation AES 128, 192 or 256 Bits <p>Symmetric</p>128 Bit Block Cipher <p>\u2705</p>via GCM mode <p>Recommended</p><p>This algorithm is considered very secure and widely studied and deployed. GCM or CBC modes are recommended.</p> ChaCha 256 Bits <p>Symmetric</p>Stream Cipher <p>\u2705</p>via Poly1305 <p>Recommended</p><p>ChaCha20 is considered very secure and is widely studied and deployed. Use of Poly1305 is recommended.</p> RSA &gt;= 1028 Bits <p>Asymmetric</p>Block Cipher ? <p>Recommended</p><p>This algorithm is considered very secure. Usually used with an symmetric encryption algorithm, while RSA \"only\" encrypts the symmetric key.</p> ECIES 256 Bits <p>Asymmetric (Hybrid)</p>Block Cipher or Stream Cipher possible ? <p>Recommended (but can be hard to implement)</p><p>This encryption scheme is considered very secure. It is not a precicse defined algorithm, but instead a framework to implement encryption when knowing the receiver's Elliptic Curve public key. It can be used with symmetric encryption algorithms (recommended: AES or ChaCha20).</p> Camellia 128, 192 or 256 Bits <p>Symmetric</p>Block Cipher \u274c <p>Considered secure</p><p>This algorithm is considered secure, but is not as widely studied or deployed as AES or ChaCha20 3DES 112 or 168 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Less secure than AES and ChaCha20</p><p>This algorithm is not inherently insecure, but it is less secure than AES or ChaCha20, and computationally more expensive.</p> DES 56 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> Blowfish 32-448 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> <p>ARC4</p>(aka \"RC4\") 40-2048 Bits Symmetric Stream Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> IDEA 128 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> Name Digest Sizes Description SHA2 224, 256, 384, 512 <p>Recommended</p><p>SHA2-family hashing functions are state-of-the-art and considered very secure. SHA2 is not less secure than SHA3.<p></p>Also known as SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.</p> SHA3 224, 256, 384, 512 <p>Recommended</p><p>SHA3-family hashing functions are state-of-the-art and considered as secure as SHA2. SHA3 was inventend as an alternative to SHA2 in case that SHA2 would be broken, but is computationally more expensive than SHA2.</p><p>Also known as SHA3/224, SHA3/256, SHA3/384 and SHA3/512.</p> SHA1 160 Bit <p>Not recommended</p><p>There are practical known collission attacks for SHA1.</p> MD5 128 Bit <p>Not recommended</p><p>There are practical known collission attacks for MD5.</p> Name Description EdDSA <p>Recommended</p><p>This algorithm is a variant of DSA, but uses \"twisted Edwards curves\", which have a few advantages1:</p><p><ul><li>High performance on a wide range of systems</li><li>More resilient to side-channel attacks</li><li>Does not require a unique random number for each messsage</li></ul></p> ECDSA <p>Recommended</p><p>This algorithm is a variant of DSA, but uses elliptic curves instead of modular arithmetic. This decreases the required key size for the same safety level drastically. Additionally, the same Public/Private Key pair could be used for encryption using ECIES, which could be an advantage.</p> RSA <p>Recommended</p><p>RSA can be used for digital signatures and asymmetric encryption using the same Public/Private key pair. Compared to ECDSA and EdDSA it has much larger key sizes and is computationally more expensive. However, if your system can profit from using the same Private/Public key pair for signing and encrypting, and the somewhat rarely used ECIES is not a feasible option for you, RSA can be a good fit.</p> DSA <p>Use EdDSA, ECDSA or RSA instead (preference in this order)</p><p>DSA was the first standardised digital signature algorithm and is still considered secure. However, the large key size and expensive computations makes it less pratical than it's modern successors such as ECDSA and EdDSA.</p> <ol> <li> <p>What is the difference between ECDSA and EdDSA? on crypto.stackexchange.com\u00a0\u21a9</p> </li> </ol>"},{"location":"algorithms/aes/","title":"AES (Advanced Encryption Standard)","text":"<p>This algorithm is recommended</p> <p>AES is considered secure6. Use AES with 128, 192 or 256 (pick the largest size feasible for your system) with GCM mode of operation. GCM provides authentication, which makes this an AEAD cipher.</p> <p>A very good and fast alternative is ChaCha, which comes in less variations and there are fewer things that can be done wrong when implementing it. Also, ChaCha might be faster on certain hardware that does not provide AES hardware-acceleration (which most common chipsets, even embedded ones, provide).</p> Disclaimer: How to use recommendations from Cryptography Primer <p>The recommendations on Cryptography Primer are based on research on multiple sources that are freely available online, such as:</p> <ul> <li>Research papers available on e.g. arxiv.org1</li> <li>Recommendations of Cryptographic Library authors</li> <li>BSI technical guidelines4</li> <li>NIST publications5</li> <li>Blogs of reknown cryptographers or cybersecurity experts</li> <li>crypto.stackexchange.com2</li> <li>security.stackexchange.com3</li> <li>and occasionally other sources</li> </ul> <p>As should always be the case, you should not take recommendations from a single source for granted, but instead find at least a second - or better, third - source that confirms this recommendation.</p> <p>Also, if you are using recommendations for anything that will be used in a production setting or will be used by anyone that relies on it's cryptograhic properties, it is highly recommended to let your concept and implementation being reviewed by a reknown cybersecurity firm.</p> <p>That being said, the author hopes that Cryptography Primer helps you find the correct algorithm to use for your scenario, and find the correct parameters and modes for a safe implementation.</p> <p>On this page you will learn:</p> <ul> <li>What is AES, and features does it provide?</li> <li>How secure is AES?</li> <li>What can I use instead of AES?</li> <li>What modes of operation can I use with AES?</li> </ul> <p>Quick Info</p> Advanced Encryption Standard Names AES, Advanced Encryption Standard, Rijndael Attributes Symmetric (Private Key), Block Cipher Features Encryption, AEAD Block Size 128 Bits (16 Bytes) Private Key Sizes 128, 192, 256 First Published 1998"},{"location":"algorithms/aes/#aes-in-practice","title":"AES in Practice","text":"<p>Hint</p> <p>The key sizes 192 and 256 do not change the block size. The block size is always 128 Bits, even when larger keys are being used.</p> <p>AES comes in multiple forms: AES-128, AES-192, AES-256. The number specifies the size of the private key that is being used. The higher the number, the higher the security (but also the slower the encryption and decryption speed). Even the smallest 128 Bit (16 Bytes) key size is currently considered secure6 and safe to use mid-term. With AES-256 you can even achieve quantum resistance from the current state of research (Januar 2022)78.</p>"},{"location":"algorithms/aes/#aes-key-generation","title":"AES Key Generation","text":"<p>Private keys for AES do not have to follow a specific form - they just need to be (crypto-secure) random bits of the required size. Other algorithms, such as RSA or EC, require the values to conform to some mathematical requirements, but AES keys do not.</p> <p>Private keys for AES do not have to follow a specific form - they just need to be (crypto-secure) random bits of the required size. Other algorithms, such as RSA or EC, require the values to conform to some mathematical requirements, but AES keys do not.</p> <p>However, it is important to make sure that the key is generated properly, because otherwise the key generation can be an attack vector - and maybe even a very easy one to attack, if key generation is not \"random enough\".</p> <p>Here are a few recommendations that you should keep in mind when implementing AES key generation:</p> <ul> <li>Use a CSPRNG (Cryptographically-secure Pseudo Random Number Generator) or HSM (Hardware Security Module), if possible     <li>Otherwise make sure that you seed your random number generator properly (don't only use the current timestamp)</li> <li>Always seed a key generator with new randomness - don't succinctly generate multiples keys from the same random number seed</li> <li>Generate keys where they will be ultimately needed and stored - e.g. don't generate keys server-side to use them on the client, but generate them client-side instead.</li> <li>Store private keys securely</li> <li>Avoid transferring private keys</li> <li>It is highly recommended to re-negotiate or rotate keys as often as possible. Don't see a Private Key as something \"permanently\" bound to a person or a node, but instead make it something ephemeral that can change on a frequent basis.</li>"},{"location":"algorithms/aes/#how-to-use-passwords-to-encryptdecrypt-with-aes","title":"How to use passwords to encrypt/decrypt with AES","text":"<p>Usually you use AES in a manner that the key is derived from the password that a user has to enter to encrypt/decrypt the data. Because the key is of fixed length (either 128, 192 or 256 Bits - which are 16, 24 or 32 Bytes, respectively), you can not use the password as the key directly, because that would impose insecure and inpractical constraints on the password that the user has to choose.</p> <p>Instead, a key derivation function is used to create an AES-compatible key from a password. PBKDF2 (Password Based Key Derivation Function 2) is a state of the art key derivation function.</p> <p>See the code sample below.</p>"},{"location":"algorithms/aes/#modes-of-operation","title":"Modes of operation","text":"<p>AES is a block-cipher, which means that it can only encrypt data with the exact block size of 128 Bits (16 Bytes). This means that it must be combined with a so-called \"Mode of operation\" in order to be able to encrypt arbitrary number of bytes. </p> <p>There are modes that add authentication to the encryption, and there are modes that do not include authentication. You must absolutely authenticate your encrypted data, because this protects against CCA10. The easiest and safest choice is to use an authenticated mode of operation. Alternatively, you can implement Encryt-then-MAC12 yourself, but this can easily be done incorrectly.</p> <p>\"GCM\" (Galois/Counter Mode) is highly recommended</p> <p>GCM provides authentication, which prevents many different kinds of attacks, and is well studied and has proven to be very secure.</p> How to pick a mode if GCM is not available <p>You can decide your mode of operation using these few rules of thumb:</p> <ol> <li>If your platform provides GCM, then use GCM.</li> <li>If your platform does not provide GCM, use CCM, EAX or OCB modes (preference in this order, consider that OCB might require a license13).</li> <li>If your platform does not provide GCM, CCM, EAX or OCB, use CTR or CFB (preference in this order) and apply Encrypt-then-MAC12.</li> <li>If your platform also does not provide CTR or CFB, reconsider your platform.</li> <li>If you can not use a platform that provides better modes, use anything except ECB, do your own research on the security of the chosen mode, and apply Encrypt-then-MAC12.</li> </ol> <p>Never ever use ECB.14</p> IV vs. nonce? <p>Neither an IV (initialization vector) nor a nonce are secret and are usually sent alongside the ciphertext.</p> <p>What is an \"Initialization Vector\"?</p> <p>The IV needs to be random (generated with a CSPRNG, as you can find in your crypto library). You must generate a new IV for each encrypted message.</p> <p>What is a \"Nonce\"?</p> <p>\"Nonce\" means \"Number only used once\". While this is also true for an IV, a nonce does not have the requirement to be random. You can safely use a steadily increasing number (a counter) as your nonce, but you must not re-use the same number for different encryptions. You must generate a new nonce for each encrypted message.</p>"},{"location":"algorithms/aes/#modes-with-authentication-aead","title":"Modes with Authentication (AEAD)","text":"Mode of Operation Full Name Description GCM Galois/Counter Mode <p>This mode is recommended</p><p>The GCM mode uses a random initialization vector (IV) for better security. This means that the same encrypted plaintext does never result in the same ciphertext. See implementation notes for GCM.</p> CCM Counter with CBC-MAC <p>Considered secure</p><p>This mode is considered secure and you can safely use it. It is somewhat slower than GCM, though.</p> EAX unknown <p>Not widely used</p><p>This mode is not widely used and hence not widely studied, so it is unsure how secure it is. While it is rather easy to implement, it is also slower than other modes.</p> OCB Offset Codebook Mode <p>This mode is patented</p><p>The OCB mode is very, very fast and considered secure. However, it is patented in the U.S. It is free to use in open source software. If you want to use it in a commercial product, you would need to require a license13 or permission to use.</p>"},{"location":"algorithms/aes/#implementation-notes-for-gcm","title":"Implementation notes for GCM","text":"<p>GCM is by far the recommended mode of operation for AES, because:</p> <ul> <li>It uses a nonce, which strengthens confidentiallity, because the same plaintext will not be encrypted to the same ciphertext.</li> <li>It provides AEAD, which prevents CCA.</li> <li>It is well supported. For example, it is used in the Web Crypto API21 and is mandatory in TLS 1.322.</li> <li>It is fast (enough), even for high throughput demands.</li> </ul> <p>However, it comes with one major caveat for implementers23. It supports a nonce of 96 Bits (12 Bytes), which is, depending on the field of application, not enough to use a random value and feel safe enough that it will be unique. After 281,474,976,710,656 messages, you have a 50% chance of re-using a nonce. In practical terms, cryptographers recommend not more than 4,294,967,296 (4 billion) messages with the same key and a random nonce. The fatal thing about this is that a nonce-reuse makes it relatively easy to recover the key and break the security completely (for future and potentially previous messages for this key).</p> <p>So, if your field of application only encrypts a few thousands or hundred thousands of messages per key, and has a good CSPRNG, you should not face a problem here. For example, when used with TLS, which creates a new Private Key for each session, this is more than unlikely to occur. However, for e.g. password-based schemes, the same key will be used permanently, or at least for a very long time, which makes this more likely.</p> <p>To prevent this problem that applies to usage of AES-GCM with long-term keys, it is recommended to either</p> <ul> <li>Implement a key rotation mechanism, if feasible. This minimizes other attack vectors, too, and might prevent the impact of a stolen or broken key.</li> <li>Implement a persistent storage and use a counter per Private Key as the nonce.</li> <li>Use AES-GCM-SIV24 instead, which uses larger nonces that are considered secure when generated at random.</li> </ul>"},{"location":"algorithms/aes/#modes-without-authentication","title":"Modes without Authentication","text":"<p>Warning</p> <p>You should only use modes without authentication when you have reasons to not use a mode with authentication (listed above).</p> <p>Unauthenticated modes are vulnerable to CCA (Chosen Ciphertext Attack), which authenticated modes are not.</p> <p>You must apply Encrypt-then-MAC12 manually in your encryption scheme to prevent CCA-attacks if you are forced to use an unauthenticated mode.</p> Mode of Operation Full Name Description CTR Counter Mode <p>Use GCM or CCM instead, if possible</p><p>Because this mode does not provide authentication, it is not recommended. However, of all the unauthenticated modes, it is the one with the strongest safety attributes and that is the least easy one to implement incorrectly. If taken care11, the IV can be a nonce and does not need to be produced by a CSPRNG, which could be an advantage. Can be parallelized.</p><p>You must apply Encrypt-then-MAC12 manually when using an unauthenticated mode</p> CFB Cipher Feedback <p>Use GCM, CCM or CTR instead, if possible</p><p>This mode is pretty similar to CBC, but chains the blocks in a different way. It is also always used with an Initialization Vector, and the IV is required to be produced by a CSPRNG.</p><p>You must apply Encrypt-then-MAC12 manually when using an unauthenticated mode.</p> CTS Ciphertext Stealing <p>Not recommended</p><p>Ciphertext stealing is a variation of ECB or CBC, but is in practice only used like CBC. The difference is that the last two blocks are chained differently. The security is not notably different from CBC.</p> CBC Cipher Block Chaining <p>Not recommended</p><p>This mode requires padding, which makes it vulnerable to padding oracle attacks17.</p> ECB Electronic Code Book <p>Do not ever use this<p><p>This method is not recommended, because it does not introduce diffusion into the ciphertext, which means that the same block is encrypted to the same ciphertext, effectively leaking patterns, which can easily be used to gain information that should be hidden.</p>"},{"location":"algorithms/aes/#security-recommendations","title":"Security Recommendations","text":"Recommended Discouraged <ul> <li>Use the largest key size that your system can handle. You can still feel secure when using 128 Bits, though, but more is better.</li> <li>Use a mode that supports authentication (AE or AEAD): GCM is recommended (see above).</li> <li>Use a key derivation function such as PBKDF2 to convert a password into an AES-compatible key.</li> <li>When you need asymmetric encryption (e.g. sender and receiver can not share a password and can not use a key exchange algorithm), use AES together with RSA and encrypt the AES-key using the RSA public key.TODO: Create a page with detailed instructions</li> </ul> <ul> <li>It is very important that you don't use the same `nonce` or `initialization vectiro` multiple times with the same key.</li> <li>Don't use a mode without authentication. (detailed explanation on Tony Arcieri's blog)</li> <li>Don't trust your crypto library's defaults - check that you are not accidentally use a discouraged practice, because your library has bad defaults.</li> <li>Don't transmit the key between two parties. Either pre-share the key over a secure medium, use a key exchange algorithm (such as DH or ECDH) or an asymmetric encryption algorithm (such as RSA) for this.</li> </ul>"},{"location":"algorithms/aes/#code-samples","title":"Code Samples","text":""},{"location":"algorithms/aes/#aes-key-generation_1","title":"AES key generation","text":"<p>This code sample shows how to securely generate a new AES key:</p> <p>Warning</p> <p>Do not use your regular \"random\" function for key generation, but use your crypto library's dedicated functions for this.</p> PythonJavaJavaScript <p>Info</p> <p>This code sample requires the widely used <code>pyca/cryptography</code> package.</p> <p>Install it with <code>pip install cryptography</code> or your favorite package manager.</p> <pre><code>from cryptography.hazmat.primitives.ciphers.aead import AESGCM\n\n# Generate a random 256 Bit private key:\nkey = AESGCM.generate_key(bit_length=256)\nprint(key.hex())\n</code></pre> <pre><code>// TODO\n</code></pre> <pre><code>// TODO\n</code></pre>"},{"location":"algorithms/aes/#key-derivation-from-passwords","title":"Key derivation from passwords","text":"<p>This code sample show how to securely derive an encryption key from a password:</p> PythonJavaJavaScript <p>Info</p> <p>This code sample requires the widely used <code>pyca/cryptography</code> package.</p> <p>Install it with <code>pip install cryptography</code> or your favorite package manager.</p> <pre><code>from cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\n# Salts should be randomly generated and need to be accessible\n# whenever a key is derived from a password. So basically,\n# the salt is usually stored/transmitted alongside the encrypted data.\n\nsalt = bytes.fromhex('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') # EXAMPLE VALUE - DO NOT USE THIS!\n\n# derive\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32, # 32 Bytes = 256 Bits\n    salt=salt,\n    iterations=100000, # This should be the minimum. You can increase the iterations if your system can handle it\n                       # to strengthen security.\n)\nkey = kdf.derive(b\"my great password\")\nprint(key.hex())\n\n# `key` can now be used with AES-256.\n\n# When you use different key sizes (AES-128 or AES-192), you need to specify\n# the corresponding length. 128 Bits = 16 Bytes, 192 Bits = 24 Bytes.\n\n# Further processing can be done to use with AES-256-GCM (explanation and code samples coming soon...)\n</code></pre> <pre><code>// TODO\n</code></pre> <pre><code>// TODO\n</code></pre>"},{"location":"algorithms/aes/#aes-encryption-and-decryption","title":"AES encryption and decryption","text":"<p>Here's a code sample on a simple use case to encrypt and decrypt data:</p> PythonJavaJavaScript <p>Info</p> <p>This code sample requires the widely used <code>pyca/cryptography</code> package.</p> <p>Install it with <code>pip install cryptography</code> or your favorite package manager.</p> <pre><code>import os\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCM\n\n# The text to be encrypted:\nplaintext = b\"I am secret\"\n\n# Can be None, when no associated data is required:\nauthenticated_text= b\"authenticated but unencrypted data\"\n\n# Generate a random private key for this example:\nkey = AESGCM.generate_key(bit_length=256)\n\n# Create an object that can encrypt/decrypt with the following cipher:\n# Algorithm: AES\n# Key Size: 256\n# Mode of Operation: GCM - an authenticated mode (see \"AEAD\")\naesgcm = AESGCM(key)\n\n# Generate a \"nonce\" for this encryption session of size 96 Bits (12 Bytes).\n# A nonce ensures that the same plaintext is not encrypted to the same ciphertext, which strenghtens security:\n\nnonce = os.urandom(12)\n# Notice: NEVER re-use the same nonce with the same key. Using a counter - if feasible - is an appropriate\n# way to prevent this. Using a random number might have a realistic chance of reuse,\n# depending on the number of messages that are being encrypted, the implementation of the random number generator\n# and the available entropy in the system.\n\n# Encrypt the data and add the authenticated (but not encrypted) data:\nciphertext = aesgcm.encrypt(nonce, plaintext, authenticated_text)\n\n# The content of \"ciphertext\" can now be shared via an untrusted medium.\n# The receiver also needs to know the \"nonce\" and the authenticated text (when used),\n# which can also be shared via an untrusted medium.\n\n# Decrypt the ciphertext back into the plaintext:\nplaintxt = aesgcm.decrypt(nonce, ciphertext, authenticated_text)\n\nprint(plaintext)\n\n# Result: \"I am secret\"\n</code></pre> <pre><code>// TODO\n</code></pre> <pre><code>// TODO\n</code></pre>"},{"location":"algorithms/aes/#security-level","title":"Security Level","text":"\"Security Level\" explained <p>In cryptography, anything that lets you decrypt a message or extract the secret key with less effort than \"brute force\" is considered a \"break\" or a possible \"attack\". \"Brute force\" means testing out the key in the whole key space - for 128 Bits (like in AES-128) this means trying all 340,282,366,920,938,463,463,374,607,431,768,211,456 possible values that an 128 Bit (16 Bytes) value can have. For 256 Bits (like in ChaCha20 or AES-256), these are 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,936 possible values.</p> <p>As you can imagine, not every \"attack\" is a real problem. Having an attacker have to try out for example 2127 values (instead of 2128) is not a risk in practice.</p> <p>With the help of certain \"attacks\" it is possible to reduce the key space required to try out in order to break the encryption. The lowest key space that you can attain for a given cipher using one or a combination of attacks is considered the \"security level\".</p> <p>In cryptography, a key space of 280 (this is a security level of 80 Bits) has long been considered secure. This might no longer be the case, depending on how strong your security needs to be. The BSI (German Institute of Cybersecurity) recommends a security level of at least 100 Bits and even 120 Bits for high security15 in 2022.</p> <p>The security level of a cipher is not fix in time. It might become lower if attacks on the cipher have been found. That is why security recommendations are valid usually not more than one or two years into the future.</p> <p>In 2022, AES is considered to have the following security levels:</p> What does it mean when a cipher is \"broken\"? <p>In cryptanalysis, which is the science of analysing and breaking cryptographic primitives, a cipher is \"broken\" if a way is found to decrypt the ciphertext or find the Private Key in less rounds than a brute force attack, which means trying all possible values in the Private Key's key space.</p> <p>In practice, not every cipher that is \"broken\" by the definition of cryptanalysis is indeed insecure. For example, for AES a technique was found to reduce the theoretic maximum key space of 256 Bits down to 254 Bits. Because this reduced key space is still large enough for modern encryption requirements, AES is still very secure, although  you might find statements that it has been \"broken\".</p> Variation Security Level Considered Secure? AES-128 126.1 Bits :fontawesome-solid-check-circle: AES-192 189.7 Bits :fontawesome-solid-check-circle: AES-256 254.4 Bits :fontawesome-solid-check-circle: <p>The security level is lower than the raw key size, because there is an attack method that allows to lower the key space that is required to be searched in order to break an encryption. This attack is called the \"Biclique attack\"16.</p>"},{"location":"algorithms/aes/#alternatives","title":"Alternatives","text":"<p>Other Symmetric Encryption algorithms are:</p> <p>Overview of encryption algorithms</p> Algorithm Key Sizes Type Authentication?(AE or AEAD) Recommendation AES 128, 192 or 256 Bits <p>Symmetric</p>128 Bit Block Cipher <p>\u2705</p>via GCM mode <p>Recommended</p><p>This algorithm is considered very secure and widely studied and deployed. GCM or CBC modes are recommended.</p> ChaCha 256 Bits <p>Symmetric</p>Stream Cipher <p>\u2705</p>via Poly1305 <p>Recommended</p><p>ChaCha20 is considered very secure and is widely studied and deployed. Use of Poly1305 is recommended.</p> RSA &gt;= 1028 Bits <p>Asymmetric</p>Block Cipher ? <p>Recommended</p><p>This algorithm is considered very secure. Usually used with an symmetric encryption algorithm, while RSA \"only\" encrypts the symmetric key.</p> ECIES 256 Bits <p>Asymmetric (Hybrid)</p>Block Cipher or Stream Cipher possible ? <p>Recommended (but can be hard to implement)</p><p>This encryption scheme is considered very secure. It is not a precicse defined algorithm, but instead a framework to implement encryption when knowing the receiver's Elliptic Curve public key. It can be used with symmetric encryption algorithms (recommended: AES or ChaCha20).</p> Camellia 128, 192 or 256 Bits <p>Symmetric</p>Block Cipher \u274c <p>Considered secure</p><p>This algorithm is considered secure, but is not as widely studied or deployed as AES or ChaCha20 3DES 112 or 168 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Less secure than AES and ChaCha20</p><p>This algorithm is not inherently insecure, but it is less secure than AES or ChaCha20, and computationally more expensive.</p> DES 56 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> Blowfish 32-448 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> <p>ARC4</p>(aka \"RC4\") 40-2048 Bits Symmetric Stream Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> IDEA 128 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p>"},{"location":"algorithms/aes/#history","title":"History","text":"Year Event 1998 First published by Vincent Rijmen, Joan Daemen 2001 Standardized by the NIST as the Advanced Encryption Standard (AES) 2003 Endorsed by the U.S. Government to protect classified information"},{"location":"algorithms/aes/#references","title":"References","text":"<ol> <li> <p>arXiv.org e-Print archive \u21a9</p> </li> <li> <p>Cryptography Stack Exchange \u21a9</p> </li> <li> <p>Information Security Stack Exchange \u21a9</p> </li> <li> <p>BSI - Cryptography on bsi.bund.de\u00a0\u21a9</p> </li> <li> <p>NIST Computer Security Resource Center on nist.gov\u00a0\u21a9</p> </li> <li> <p>Is 128-bit security still considered strong in 2020, within the context of both ECC Asym &amp; Sym ciphers on crypto.stackexchange.com.\u00a0\u21a9\u21a9</p> </li> <li> <p>Is AES-256 a post-quantum secure cipher or not? on crypto.stackexchange.com.\u00a0\u21a9</p> </li> <li> <p>Post-quantum cryptography on Wikipedia\u00a0\u21a9</p> </li> <li> <p>Using Encryption and Authentication Correctly (for PHP developers) \u21a9</p> </li> <li> <p>All the crypto code you\u2019ve ever written is probably broken as blogged by Tony Arcieri.\u00a0\u21a9</p> </li> <li> <p>\"Counter (CTR)\" at \"Block cipher mode of operation\" on Wikipedia\u00a0\u21a9</p> </li> <li> <p>Should we MAC-then-encrypt or encrypt-then-MAC? \u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Free Licenses on www.cs.ucdavis.edu by Phillip Rogaway\u00a0\u21a9\u21a9</p> </li> <li> <p>\"Electronic codebook (ECB)\" at \"Block cipher mode of operation\" on Wikipedia\u00a0\u21a9</p> </li> <li> <p>BSI - Technical Guide - Cryptographic Mechanisms: Recommendations and Key Lengths on bsi.bund.de\u00a0\u21a9</p> </li> <li> <p>Biclique attack on Wikipedia\u00a0\u21a9</p> </li> <li> <p>Padding oracle attack on Wikipedia\u00a0\u21a9</p> </li> <li> <p>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC on csrc.nist.gov\u00a0\u21a9</p> </li> <li> <p>Hardware Security Module on Wikipedia\u00a0\u21a9</p> </li> <li> <p>Cryptographically-secure pseudorandom number generator on Wikipedia\u00a0\u21a9</p> </li> <li> <p>Web Crypto API's \"SubtleCrypto.encrypt()\" at MDN on developer.mozilla.org\u00a0\u21a9</p> </li> <li> <p>RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3 on ietf.org\u00a0\u21a9</p> </li> <li> <p>Why AES-GCM Sucks on soatok.blog\u00a0\u21a9</p> </li> <li> <p>RFC 8452: AES-GCM-SIV: Nonce Misuse-Resistant Authenticated Encryption on ietf.org\u00a0\u21a9</p> </li> </ol>"},{"location":"algorithms/chacha/","title":"ChaCha","text":"<p>This algorithm is recommended</p> <p>Use ChaCha in it's XChaCha20-Poly1305 or ChaCha20-Poly1305 variations.</p> <p>XChaCha20-Poly1305 and ChaCha20-Poly1305 are considered secure6 and fast. It has a strong security level and provides authentication (AEAD).</p> <p>It is arguably easier to use than AES, because it has less (insecure) variations and modes of operation. However, when using AES as AES-256-GCM, the differences in security to ChaCha20-Poly1305 are negligible. Note that AES is only fast to use when hardware acceleration is available - while this is very common nowadays, it might be a constraint to consider. ChaCha can be implemented very fast in software only and does not require special CPU instructions.</p> Disclaimer: How to use recommendations from Cryptography Primer <p>The recommendations on Cryptography Primer are based on research on multiple sources that are freely available online, such as:</p> <ul> <li>Research papers available on e.g. arxiv.org1</li> <li>Recommendations of Cryptographic Library authors</li> <li>BSI technical guidelines4</li> <li>NIST publications5</li> <li>Blogs of reknown cryptographers or cybersecurity experts</li> <li>crypto.stackexchange.com2</li> <li>security.stackexchange.com3</li> <li>and occasionally other sources</li> </ul> <p>As should always be the case, you should not take recommendations from a single source for granted, but instead find at least a second - or better, third - source that confirms this recommendation.</p> <p>Also, if you are using recommendations for anything that will be used in a production setting or will be used by anyone that relies on it's cryptograhic properties, it is highly recommended to let your concept and implementation being reviewed by a reknown cybersecurity firm.</p> <p>That being said, the author hopes that Cryptography Primer helps you find the correct algorithm to use for your scenario, and find the correct parameters and modes for a safe implementation.</p> <p>On this page you will learn:</p> <ul> <li>What is ChaCha, and features does it provide?</li> <li>How secure is ChaCha?</li> <li>What can I use instead of ChaCha?</li> <li>What modes of operation can I use with ChaCha?</li> </ul> <p>Quick Info</p> ChaCha Names ChaCha (with various additions, see below) Attributes Symmetric (Private Key), Stream Cipher Features Encryption, AEAD Private Key Size 256 Bits (32 Bytes) First Published 2008"},{"location":"algorithms/chacha/#chacha-in-practice","title":"ChaCha in Practice","text":"<p>In practice, ChaCha is mostly used as the ChaCha20-Poly1305 variant, which is also recommended. The Private Key is always 256 Bits (32 Bytes). There are variations that trade security for speed by reducing the number of internal computation rounds: ChaCha12 and ChaCha8. We will not go into detail on these variants, because they are seldomly used.</p>"},{"location":"algorithms/chacha/#chacha-key-generation","title":"ChaCha Key Generation","text":"<p>Private keys for ChaCha do not have to follow a specific form - they just need to be (crypto-secure) random bits of the required size. Other algorithms, such as RSA or EC, require the values to conform to some mathematical requirements, but ChaCha keys do not.</p> <p>However, it is important to make sure that the key is generated properly, because otherwise the key generation can be an attack vector - and maybe even a very easy one to attack, if key generation is not \"random enough\".</p> <p>Here are a few recommendations that you should keep in mind when implementing ChaCha key generation:</p> <ul> <li>Use a CSPRNG (Cryptographically-secure Pseudo Random Number Generator) or HSM (Hardware Security Module), if possible     <li>Otherwise make sure that you seed your random number generator properly (don't only use the current timestamp)</li> <li>Always seed a key generator with new randomness - don't succinctly generate multiples keys from the same random number seed</li> <li>Generate keys where they will be ultimately needed and stored - e.g. don't generate keys server-side to use them on the client, but generate them client-side instead.</li> <li>Store private keys securely</li> <li>Avoid transferring private keys</li> <li>It is highly recommended to re-negotiate or rotate keys as often as possible. Don't see a Private Key as something \"permanently\" bound to a person or a node, but instead make it something ephemeral that can change on a frequent basis.</li>"},{"location":"algorithms/chacha/#how-to-use-passwords-to-encryptdecrypt-with-chacha","title":"How to use passwords to encrypt/decrypt with ChaCha","text":"<p>Usually you use ChaCha in a manner that the key is derived from the password that a user has to enter to encrypt/decrypt the data. Because the key is of fixed length (256 Bits, which are 32 Bytes), you can not use the password as the key directly, because that would impose insecure and inpractical constraints on the password that the user has to choose.</p> <p>Instead, a key derivation function is used to create an ChaCha-compatible key from a password. PBKDF2 (Password Based Key Derivation Function 2) is a state of the art key derivation function.</p> <p>TODO: See the code sample below.</p>"},{"location":"algorithms/chacha/#modes-of-operation","title":"Modes of operation","text":"<p>ChaCha is a Stream Cipher, which means that it can encode arbitrary length of data - in contrast to Block Ciphers, which need \"modes of operation\" that help concatenate and pad data so that it fits into multiple of the Block Cipher's block size.</p> <p>So ChaCha can be used \"raw\" as it is, in theory. But in practice, you should use ChaCha together with a MAC to achieve AEAD to make the cipher resitant to CCA. By far the most common MAC used with ChaCha is Poly1305, which makes ChaCha20-Poly1305 the most common incarnation of ChaCha nowadays.</p> Cipher Description XChaCha20-Poly1305 <p>Recommended</p><p>This is basically the same as ChaCha20-Poly1305, but uses a larger nonce of 192 Bit (24 Bytes). Because nonce-reuse12 is the point of an implementation that can go wrong easiest, XChaCha20-Poly1305 offers more \"ease of implementation\", because it makes it practically feasible to use random numbers as nonces easily. Other than that, the security attributes are equal to ChaCha20-Poly1305</p> ChaCha20-Poly1305 <p>Recommended if you can't use XChaCha20-Poly1305</p><p>ChaCha20-Poly1305 is a very common Stream Cipher that is considered secure. It is widely deployed, studied and very fast. Because it uses a smaller nonce than XChaCha20-Poly1305, the dangers of accidental nonce-reuse12 is higher, which makes it a bit more error prone. Other than that, the security attributes are equal to XChaCha20-Poly1305.</p> ChaCha20 <p>Use ChaCha20-Poly1305 instead</p><p>Raw ChaCha20 without authentication is not recommended, because there is usually no reason not to use ChaCha20-Poly1305 instead.</p> ChaCha12 <p>Use only combined with authentication</p><p>While the reduction of the rounds might not impose practically weaker security10, there is no common or standardized cipher that uses ChaCha12 with authentication, which is why you should use XChaCha20-Poly1305 or ChaCha20-Poly1305 instead, if feasible. If you require the higher throughput/faster speed that ChaCha12 provides, you need to apply Encrypt-then-MAC11<p> ChaCha8 <p>Use only combined with authentication</p><p>While the reduction of the rounds might not impose practically weaker security10, there is no common or standardized cipher that uses ChaCha8 with authentication, which is why you should use XChaCha20-Poly1305 or ChaCha20-Poly1305 instead, if feasible. If you require the higher throughput/faster speed that ChaCha8 provides, you need to apply Encrypt-then-MAC11<p>"},{"location":"algorithms/chacha/#security-recommendations","title":"Security Recommendations","text":"Recommended Discouraged <ul> <li>Use ChaCha20-Poly1305.</li> <li>Use a key derivation function such as PBKDF2 to convert a password into an ChaCha-compatible key.</li> <li>When you need asymmetric encryption (e.g. sender and receiver can not share a password and can not use a key exchange algorithm), use ChaCha20 together with RSA and encrypt the ChaCha-key using the RSA public key.TODO: Create a page with detailed instructions</li> </ul> <ul> <li>It is very important that you don't use the same nonce multiple times with the same key.</li> <li>Don't use raw ChaCha ciphers (e.g. without Poly1305). (detailed explanation on Tony Arcieri's blog)</li> <li>Don't trust your crypto library's defaults - check that you are not accidentally use a discouraged practice, because your library has bad defaults.</li> <li>Don't transmit the key between two parties. Either pre-share the key over a secure medium, use a key exchange algorithm (such as DH or ECDH) or an asymmetric encryption algorithm (such as RSA) for this.</li> </ul>"},{"location":"algorithms/chacha/#code-samples","title":"Code Samples","text":""},{"location":"algorithms/chacha/#chacha-key-generation_1","title":"ChaCha key generation","text":"<p>This code sample shows how to securely generate a new ChaCha key:</p> <p>Warning</p> <p>Do not use your regular \"random\" function for key generation, but use your crypto library's dedicated functions for this.</p> PythonJavaJavaScript <p>Info</p> <p>This code sample requires the widely used <code>pyca/cryptography</code> package.</p> <p>Install it with <code>pip install cryptography</code> or your favorite package manager.</p> <pre><code>from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305\n\n# Generate a random 256 Bit private key:\nkey = ChaCha20Poly1305.generate_key()\nprint(key.hex())\n</code></pre> <pre><code>// TODO\n</code></pre> <pre><code>// TODO\n</code></pre>"},{"location":"algorithms/chacha/#key-derivation-from-passwords","title":"Key derivation from passwords","text":"<p>This code sample show how to securely derive an encryption key from a password:</p> PythonJavaJavaScript <p>Info</p> <p>This code sample requires the widely used <code>pyca/cryptography</code> package.</p> <p>Install it with <code>pip install cryptography</code> or your favorite package manager.</p> <pre><code>from cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\n# Salts should be randomly generated and need to be accessible\n# whenever a key is derived from a password. So basically,\n# the salt is usually stored/transmitted alongside the encrypted data.\n\nsalt = bytes.fromhex('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') # EXAMPLE VALUE - DO NOT USE THIS!\n\n# derive\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32, # 32 Bytes = 256 Bits\n    salt=salt,\n    iterations=100000, # This should be the minimum. You can increase the iterations if your system can handle it\n                       # to strengthen security.\n)\nkey = kdf.derive(b\"my great password\")\nprint(key.hex())\n\n# `key` can now be used with ChaCha20-Poly1305\n</code></pre> <pre><code>// TODO\n</code></pre> <pre><code>// TODO\n</code></pre>"},{"location":"algorithms/chacha/#chacha20-poly1305-encryption-and-decryption","title":"ChaCha20-Poly1305 encryption and decryption","text":"<p>Here's a code sample on a simple use case to encrypt and decrypt data:</p> PythonJavaJavaScript <p>Info</p> <p>This code sample requires the widely used <code>pyca/cryptography</code> package.</p> <p>Install it with <code>pip install cryptography</code> or your favorite package manager.</p> <pre><code>import os\nfrom cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305\n\n# The text to be encrypted:\nplaintext = b\"I am secret\"\n\n# Can be None, when no associated data is required:\nauthenticated_text= b\"authenticated but unencrypted data\"\n\n# Generate a random private key for this example:\nkey = ChaCha20Poly1305.generate_key()\n\n# Create an object that can encrypt/decrypt with the ChaCha20-Poly1305 AEAD cipher:\nchacha = ChaCha20Poly1305(key)\n\n# Generate a \"nonce\" for this encryption session of size 96 Bits (12 Bytes).\n# A nonce ensures that the same plaintext is not encrypted to the same ciphertext, which strenghtens security:\n\nnonce = os.urandom(12)\n# Notice: NEVER re-use the same nonce with the same key. Using a counter - if feasible - is an appropriate\n# way to prevent this. Using a random number might have a realistic chance of reuse,\n# depending on the number of messages that are being encrypted, the implementation of the random number generator\n# and the available entropy in the system.\n\n# Encrypt the data and add the authenticated (but not encrypted) data:\nciphertext = chacha.encrypt(nonce, plaintext, authenticated_text)\n\n# The content of \"ciphertext\" can now be shared via an untrusted medium.\n# The receiver also needs to know the \"nonce\" and the authenticated text (when used),\n# which can also be shared via an untrusted medium.\n\n# Decrypt the ciphertext back into the plaintext:\nplaintxt = chacha.decrypt(nonce, ciphertext, authenticated_text)\n\nprint(plaintext)\n\n# Result: \"I am secret\"\n</code></pre> <pre><code>// TODO\n</code></pre> <pre><code>// TODO\n</code></pre>"},{"location":"algorithms/chacha/#security-level","title":"Security Level","text":"\"Security Level\" explained <p>In cryptography, anything that lets you decrypt a message or extract the secret key with less effort than \"brute force\" is considered a \"break\" or a possible \"attack\". \"Brute force\" means testing out the key in the whole key space - for 128 Bits (like in AES-128) this means trying all 340,282,366,920,938,463,463,374,607,431,768,211,456 possible values that an 128 Bit (16 Bytes) value can have. For 256 Bits (like in ChaCha20 or AES-256), these are 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,936 possible values.</p> <p>As you can imagine, not every \"attack\" is a real problem. Having an attacker have to try out for example 2127 values (instead of 2128) is not a risk in practice.</p> <p>With the help of certain \"attacks\" it is possible to reduce the key space required to try out in order to break the encryption. The lowest key space that you can attain for a given cipher using one or a combination of attacks is considered the \"security level\".</p> <p>In cryptography, a key space of 280 (this is a security level of 80 Bits) has long been considered secure. This might no longer be the case, depending on how strong your security needs to be. The BSI (German Institute of Cybersecurity) recommends a security level of at least 100 Bits and even 120 Bits for high security[^10] in 2022.</p> <p>The security level of a cipher is not fix in time. It might become lower if attacks on the cipher have been found. That is why security recommendations are valid usually not more than one or two years into the future.</p> <p>In 2022, ChaCha20 is considered to have a full security level of 256 Bits, which is it's original Key Size. To quote the report8 \"Security Analysis of ChaCha20-Poly1305 AEAD\" from KDDI Research:</p> <p>Quote</p> <p>Therefore, we conclude that we cannot find any weaknesses in ChaCha20-Poly1305 AEAD.</p> What does it mean when a cipher is \"broken\"? <p>In cryptanalysis, which is the science of analysing and breaking cryptographic primitives, a cipher is \"broken\" if a way is found to decrypt the ciphertext or find the Private Key in less rounds than a brute force attack, which means trying all possible values in the Private Key's key space.</p> <p>In practice, not every cipher that is \"broken\" by the definition of cryptanalysis is indeed insecure. For example, for AES a technique was found to reduce the theoretic maximum key space of 256 Bits down to 254 Bits. Because this reduced key space is still large enough for modern encryption requirements, AES is still very secure, although  you might find statements that it has been \"broken\".</p> Variation Security Level Considered Secure? ChaCha20 256 Bits :fontawesome-solid-check-circle: ChaCha12 256 Bits :fontawesome-solid-check-circle: ChaCha8 256 Bits :fontawesome-solid-check-circle: <p>The smaller variants of ChaCha, namely ChaCha12 and ChaCha8 might have weaker security than ChaCha20, but no practical attacks10 are known, yet. Even the smallest round variant, ChaCha8, is considered secure. The safest that cryptanalysis got in 2022 is reducing the Security Level of a reduced variant of ChaCha with 7 rounds, which you will not find implemented in your crypto library, to (maybe, this is a bit unclear) 237.7 Bits7.</p>"},{"location":"algorithms/chacha/#alternatives","title":"Alternatives","text":"<p>Other Symmetric Encryption algorithms are:</p> <p>Overview of encryption algorithms</p> Algorithm Key Sizes Type Authentication?(AE or AEAD) Recommendation AES 128, 192 or 256 Bits <p>Symmetric</p>128 Bit Block Cipher <p>\u2705</p>via GCM mode <p>Recommended</p><p>This algorithm is considered very secure and widely studied and deployed. GCM or CBC modes are recommended.</p> ChaCha 256 Bits <p>Symmetric</p>Stream Cipher <p>\u2705</p>via Poly1305 <p>Recommended</p><p>ChaCha20 is considered very secure and is widely studied and deployed. Use of Poly1305 is recommended.</p> RSA &gt;= 1028 Bits <p>Asymmetric</p>Block Cipher ? <p>Recommended</p><p>This algorithm is considered very secure. Usually used with an symmetric encryption algorithm, while RSA \"only\" encrypts the symmetric key.</p> ECIES 256 Bits <p>Asymmetric (Hybrid)</p>Block Cipher or Stream Cipher possible ? <p>Recommended (but can be hard to implement)</p><p>This encryption scheme is considered very secure. It is not a precicse defined algorithm, but instead a framework to implement encryption when knowing the receiver's Elliptic Curve public key. It can be used with symmetric encryption algorithms (recommended: AES or ChaCha20).</p> Camellia 128, 192 or 256 Bits <p>Symmetric</p>Block Cipher \u274c <p>Considered secure</p><p>This algorithm is considered secure, but is not as widely studied or deployed as AES or ChaCha20 3DES 112 or 168 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Less secure than AES and ChaCha20</p><p>This algorithm is not inherently insecure, but it is less secure than AES or ChaCha20, and computationally more expensive.</p> DES 56 Bits <p>Symmetric</p>64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> Blowfish 32-448 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> <p>ARC4</p>(aka \"RC4\") 40-2048 Bits Symmetric Stream Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p> IDEA 128 Bits Symmetric 64 Bit Block Cipher \u274c <p>Not recommended</p><p>This algorithm is no longer considered secure</p>"},{"location":"algorithms/chacha/#history","title":"History","text":"Year Event 2008 First published by D. J. Bernstein9"},{"location":"algorithms/chacha/#references","title":"References","text":"<ol> <li> <p>arXiv.org e-Print archive \u21a9</p> </li> <li> <p>Cryptography Stack Exchange \u21a9</p> </li> <li> <p>Information Security Stack Exchange \u21a9</p> </li> <li> <p>BSI - Cryptography on bsi.bund.de\u00a0\u21a9</p> </li> <li> <p>NIST Computer Security Resource Center on nist.gov\u00a0\u21a9</p> </li> <li> <p>TODO: Find a reference that recognizes ChaCha20-Poly1305 as secure\u00a0\u21a9</p> </li> <li> <p>Analysis of Salsa, ChaCha, and Rumba by Jean-Philippe Aumasson, Simon Fischer, Shahram Khazaei, Willi Meier, and Christian Rechberger on eprint.iacr.org\u00a0\u21a9</p> </li> <li> <p>Security Analysis of ChaCha20-Poly1305 AEAD by KDDI Research, Inc. on cryptrec.go.jp\u00a0\u21a9</p> </li> <li> <p>The ChaCha family of stream ciphers by D. J. Bernstein on cr.yp.to\u00a0\u21a9</p> </li> <li> <p>Too Much Crypto by Jean-Philippe Aumasson on eprint.iacr.org\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Should we MAC-then-encrypt or encrypt-then-MAC? \u21a9\u21a9</p> </li> <li> <p>Nonce reuse in encryption - what\u2019s the worst that can happen? by Christian Lundkvist on github.com\u00a0\u21a9\u21a9</p> </li> </ol>"}]}